---
## Front matter
title: "Доклад"
subtitle: "Ошибки проверки вводимых данных: межсайтовый скриптинг в веб-приложениях, межсайтовый скриптинг при наличии SQL-инъекции"
author: "Зинченко Анастасия Романовна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Введение

Проверка вводимых данных — это один из ключевых аспектов информационной безопасности веб-приложений. Неправильная или недостаточная проверка пользовательского ввода может привести к серьёзным уязвимостям, включая межсайтовый скриптинг (XSS) и SQL-инъекции.

# Межсайтовый скриптинг (XSS)

XSS (Cross-Site Scripting) — это тип уязвимости, при которой злоумышленник внедряет вредоносный скрипт на сайт. Этот скрипт затем выполняется в браузере другого пользователя, обычно без его ведома.

Разновидности XSS:

1. Отражённый (Reflected XSS) — вредоносный код возвращается в ответе сервера немедленно, часто через параметры URL.
2. Сохранённый (Stored XSS) — скрипт сохраняется на сервере и автоматически исполняется при открытии определённой страницы.
3. DOM-based XSS — уязвимость возникает на стороне клиента, когда JavaScript обрабатывает вход без должной фильтрации.

# SQL-инъекция и её связь с XSS

SQL-инъекция — это тип атаки, при которой злоумышленник внедряет SQL-код в поле ввода, чтобы изменить поведение запроса к базе данных.

Классическая форма: SELECT * FROM users WHERE name = 'ввод пользователя';

Если пользователь введёт: ' OR '1'='1

Запрос станет: SELECT * FROM users WHERE name = '' OR '1'='1';

# XSS через SQL-инъекцию

Как это работает:

Иногда SQL-инъекция позволяет злоумышленнику внедрить JavaScript-код прямо в базу данных. Если затем эта информация отображается на странице без экранирования — срабатывает XSS.

Пример:

Хакер вводит: <script>stealCookies()</script> в поле комментария. Комментарий сохраняется в БД. На странице отображается: <div>Комментарий: <script>stealCookies()</script></div> Браузер пользователя исполняет скрипт, возможно, передавая куки злоумышленнику. 
Последствия:
1. Кража сессий.
2. Подмена интерфейса сайта.
3. Распространение вредоносного ПО.

# Почему это происходит

Основные причины:
1. Отсутствие серверной валидации данных. Многие разработчики полагаются только на проверку данных на клиентской стороне (в браузере) — например, с 
помощью JavaScript. Но такую проверку очень легко обойти: хакер может отключить JavaScript или отправить HTTP-запрос напрямую, минуя форму на сайте. Итог: 
вредоносный ввод попадает в серверную часть приложения без фильтрации.
2. Прямой вывод данных без экранирования. Многие веб-приложения не экранируют пользовательские данные перед отображением их в HTML. Это делает страницу 
уязвимой к XSS. Что значит экранировать? Преобразовать специальные символы в безопасные HTML-сущности. Если этого не сделать, браузер может воспринять 
пользовательский ввод как настоящий код.
3. Использование небезопасных SQL-запросов с прямой подстановкой данных. Разработчики часто вставляют данные от пользователя прямо в SQL-запросы, не 
фильтруя их. Это называется "динамический SQL".
4. Прямое доверие к данным из внешних источников. Веб-приложения часто получают данные от форм ввода, из URL-параметров, из куки, из API-запросов. Если к 
этим данным относится с доверием, без проверки и очистки, то возникает уязвимость. В итоге ошибки проверки ввода — это результат невнимательного
проектирования, недостатка знаний о безопасности, упрощения логики "ради скорости". Чтобы их избежать, нужно всегда фильтровать и экранировать данные по 
месту их использования, никогда не доверять внешним источникам данных, использовать готовые безопасные библиотеки и шаблонизаторы, помнить, что
безопасность — это процесс, а не разовая проверка.

# Методы защиты 

Для предотвращения XSS:
1. Экранирование HTML при выводе. Перед выводом данных на страницу HTML, любые специальные символы (например, <, >, ", ', /) должны быть заменены на их 
HTML-сущности.
2. Использование безопасных шаблонизаторов. Шаблонизаторы, такие как Twig (PHP), Jinja2 (Python), Handlebars (JavaScript) автоматически экранируют данные, 
предотвращая внедрение скриптов.
3. Запрет выполнения скриптов с помощью Content Security Policy (CSP). Это HTTP-заголовок, который запрещает выполнение несанкционированного JavaScript. 
В результате скрипты из внешних источников и инлайновые скрипты (если не разрешены) не выполнятся, даже если XSS внедрён.
4. Проверка и фильтрация входных данных. Фильтрация — удаление или замена опасных символов. Валидация — проверка, соответствует ли ввод ожидаемому формату 
(например, email, число, имя).
Для предотвращения SQL-инъекций:
1. Использование подготовленных выражений (prepared statements). SQL-запрос и данные передаются отдельно. Это исключает возможность вмешательства данных в 
структуру запроса.
2. Использование ORM. ORM (Object-Relational Mapping) — это библиотеки, которые позволяют работать с базой данных через объекты, не создавая вручную SQL-
запросы. Преимущества: SQL-инъекции исключены по архитектуре, упрощается валидация и логика.
3. Изоляция пользовательского ввода.
4. Минимизация прав учетной записи базы данных.
Общие рекомендации:
1. Никогда не доверяйте данным от пользователя.
2. Проверка данных на клиенте — это удобно, но не надёжно, необходима серверная проверка.

# Заключение

Межсайтовый скриптинг и SQL-инъекции — это старые, но всё ещё крайне опасные уязвимости, часто возникающие из-за одних и тех же причин: доверия к пользовательскому вводу. Их комбинация может иметь катастрофические последствия — от утечки персональных данных до полного захвата веб-приложения.

# Выводы 

Комплексная защита, основанная на принципах нулевого доверия, экранирования, фильтрации и безопасных API — ключ к устойчивой архитектуре веб-приложений.
